<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title id="pageTitle">Book Images</title>
    <style>
      #imagesContainer {
        display: flex;
        overflow-x: auto;
        height: 100vh;
      }
      #imagesContainer img {
        height: 100%;
        object-fit: contain;
      }
    </style>
  </head>
  <body>
    <h2 id="bookNameBeforeNumber">Book's name</h2>
    <div id="imagesContainer"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>
    <script>
      async function displayImages(zip) {
        const imagesContainer = document.getElementById("imagesContainer");
        imagesContainer.innerHTML = ""; // Clear previous images

        for (const fileName of Object.keys(zip.files)) {
          const file = zip.files[fileName];

          if (!file.dir && /\.(jpe?g|png|gif)$/i.test(fileName)) {
            const blob = await file.async("blob");
            const img = document.createElement("img");
            img.src = URL.createObjectURL(blob);
            imagesContainer.appendChild(img);
          }
        }
      }

      async function loadBook() {
        const bookName = new URLSearchParams(window.location.search).get(
          "bookName"
        );

        if (!bookName) {
          alert("Missing book name.");
          return;
        }

        console.log("Loading book:", bookName);

        // Extract the number from the bookName and set it as the title
        const bookNumber = bookName.match(/\d+/)[0];
        const bookNumberWithBrackets = "[" + bookNumber + "]";
        const bookNameBeforeNumber = bookName.split(bookNumberWithBrackets)[0];
        document.getElementById("pageTitle").textContent = bookNumber;
        document.getElementById("bookNameBeforeNumber").textContent =
          bookNameBeforeNumber;

        try {
          const bookDataArray = await getBookDataArray(bookName);

          if (bookDataArray && bookDataArray.length > 0) {
            const decryptedDataArray = [];
            for (const bookData of bookDataArray) {
              console.log("Decrypting with password:", bookData.password);
              const decryptedData = await decryptFolder(
                bookData.data,
                bookData.password
              );
              if (decryptedData) {
                decryptedDataArray.push(decryptedData);
              } else {
                console.error("Decryption failed for part of the book data.");
                return;
              }
            }

            const combinedData = combineArrayBuffers(decryptedDataArray);
            const zip = await JSZip.loadAsync(combinedData);
            displayImages(zip);
          } else {
            alert("Book data not found.");
          }
        } catch (error) {
          console.error("Error retrieving book data:", error);
          alert("Failed to retrieve book data.");
        }
      }

      async function getBookDataArray(bookName) {
        return new Promise((resolve, reject) => {
          const request = indexedDB.open("bookDatabase", 1);

          request.onsuccess = function (event) {
            const db = event.target.result;
            const transaction = db.transaction("books", "readonly");
            const store = transaction.objectStore("books");

            const query = store.get(bookName);

            query.onsuccess = function () {
              const item = query.result;
              if (item) {
                const bookData = query.result;
                console.log("Retrieved data type:", typeof bookData.data);
                console.log("First 50 chars:", bookData.data.slice(0, 50));
                console.log("Last 50 chars:", bookData.data.slice(-50));

                resolve([
                  {
                    data: base64ToArrayBuffer(item.data),
                    password: item.password,
                  },
                ]);
              } else {
                console.log("No data found for book:", bookName);
                resolve([]);
              }
            };

            query.onerror = function () {
              console.error("Query error:", query.error);
              reject(query.error);
            };
          };

          request.onerror = function () {
            console.error("IndexedDB open error:", request.error);
            reject(request.error);
          };
        });
      }

      function combineArrayBuffers(dataArray) {
        const totalLength = dataArray.reduce(
          (acc, data) => acc + data.byteLength,
          0
        );
        const combinedArray = new Uint8Array(totalLength);
        let offset = 0;

        dataArray.forEach((data, index) => {
          const arrayBuffer = new Uint8Array(data);
          combinedArray.set(arrayBuffer, offset);
          offset += arrayBuffer.byteLength;
          console.log(
            `Combined data part ${index + 1} length:`,
            arrayBuffer.byteLength
          );
        });

        console.log("Total combined data length:", combinedArray.byteLength);
        return combinedArray.buffer;
      }

      function base64ToArrayBuffer(base64) {
        try {
          let cleanedBase64 = base64.replace(/[^A-Za-z0-9+/=]/g, "");
          cleanedBase64 = cleanedBase64.replace(/-/g, "+").replace(/_/g, "/"); // Fix URL-safe encoding issues

          console.log("Cleaned base64 length:", cleanedBase64.length);
          console.log("Last 10 chars:", cleanedBase64.slice(-10));

          const binaryString = atob(cleanedBase64);
          console.log("atob OK");

          const bytes = new Uint8Array(binaryString.length);
          for (let i = 0; i < binaryString.length; i++) {
            bytes[i] = binaryString.charCodeAt(i);
          }
          return bytes.buffer;
        } catch (error) {
          console.error("Base64 conversion failed:", error.message, base64);
          alert("Base64 decoding error. The book file might be corrupted.");
          return null;
        }
      }

      async function decryptFolder(combinedData, password) {
        const iv = combinedData.slice(0, 12);
        const encryptedData = combinedData.slice(12);

        console.log("IV length:", iv.byteLength);
        console.log("Encrypted Data Length:", encryptedData.byteLength);

        const key = await crypto.subtle.digest(
          "SHA-256",
          new TextEncoder().encode(password)
        );

        console.log("Key generated:", key);

        try {
          const decryptedData = await crypto.subtle.decrypt(
            { name: "AES-GCM", iv },
            await crypto.subtle.importKey(
              "raw",
              key,
              { name: "AES-GCM" },
              false,
              ["decrypt"]
            ),
            encryptedData
          );

          console.log("Decryption successful");
          return decryptedData;
        } catch (error) {
          console.error("Decryption failed:", error);
          alert("Decryption error. The book file might be corrupted.");
          return null;
        }
      }

      window.onload = loadBook;
    </script>
  </body>
</html>
