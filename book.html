<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title id="pageTitle">Book Images</title>
    <style>
      #imagesContainer {
        display: flex;
        overflow-x: auto;
        height: 100vh;
      }
      #imagesContainer img {
        height: 100%;
        object-fit: contain;
      }
    </style>
  </head>
  <body>
    <h2 id="bookNameBeforeNumber">Book's name</h2>
    <div id="imagesContainer"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>
    <script>
      async function displayImages(zip) {
        const imagesContainer = document.getElementById("imagesContainer");
        imagesContainer.innerHTML = ""; // Clear previous images

        for (const fileName of Object.keys(zip.files)) {
          const file = zip.files[fileName];

          if (!file.dir && /\.(jpe?g|png|gif)$/i.test(fileName)) {
            const blob = await file.async("blob");
            const img = document.createElement("img");
            img.src = URL.createObjectURL(blob);
            imagesContainer.appendChild(img);
          }
        }
      }

      async function loadBook() {
        const bookName = new URLSearchParams(window.location.search).get(
          "bookName"
        );

        if (!bookName) {
          alert("Missing book name.");
          return;
        }

        // Extract the number from the bookName and set it as the title
        const bookNumber = bookName.match(/\d+/)[0];
        const bookNumberWithBrackets = "[" + bookNumber + "]";
        const bookNameBeforeNumber = bookName.split(bookNumberWithBrackets)[0];
        document.getElementById("pageTitle").textContent = bookNumber;
        document.getElementById("bookNameBeforeNumber").textContent =
          bookNameBeforeNumber;

        try {
          const bookDataArray = await getBookDataArray(bookName);

          if (bookDataArray && bookDataArray.length > 0) {
            const decryptedDataArray = [];
            for (const bookData of bookDataArray) {
              const decryptedData = await decryptFolder(
                bookData.data,
                bookData.password
              );
              decryptedDataArray.push(decryptedData);
            }

            const combinedData = combineArrayBuffers(decryptedDataArray);
            const zip = await JSZip.loadAsync(combinedData);
            displayImages(zip);
          } else {
            alert("Book data not found.");
          }
        } catch (error) {
          alert("Failed to retrieve book data.");
        }
      }

      async function getBookDataArray(bookName) {
        return new Promise((resolve, reject) => {
          const request = indexedDB.open("bookDatabase", 1);

          request.onsuccess = function (event) {
            const db = event.target.result;
            const transaction = db.transaction("books", "readonly");
            const store = transaction.objectStore("books");

            const query = store.get(bookName);

            query.onsuccess = function () {
              const item = query.result;
              if (item) {
                resolve([
                  {
                    data: base64ToArrayBuffer(item.data),
                    password: item.password,
                  },
                ]);
              } else {
                resolve([]);
              }
            };

            query.onerror = function () {
              reject(query.error);
            };
          };

          request.onerror = function () {
            reject(request.error);
          };
        });
      }

      function combineArrayBuffers(dataArray) {
        const totalLength = dataArray.reduce(
          (acc, data) => acc + data.byteLength,
          0
        );
        const combinedArray = new Uint8Array(totalLength);
        let offset = 0;

        dataArray.forEach((data) => {
          const arrayBuffer = new Uint8Array(data);
          combinedArray.set(arrayBuffer, offset);
          offset += arrayBuffer.byteLength;
        });

        return combinedArray.buffer;
      }

      function cleanBase64String(base64) {
        return base64.replace(/[^A-Za-z0-9+/=]/g, "");
      }

      function base64ToArrayBuffer(base64) {
        try {
          const cleanedBase64 = cleanBase64String(base64);

          if (!/^[A-Za-z0-9+/=]+$/.test(cleanedBase64)) {
            throw new Error("Invalid base64 characters detected!");
          }

          const binaryString = atob(cleanedBase64);
          const bytes = new Uint8Array(binaryString.length);
          for (let i = 0; i < binaryString.length; i++) {
            bytes[i] = binaryString.charCodeAt(i);
          }
          return bytes.buffer;
        } catch (error) {
          console.error("Base64 conversion failed:", error.message, base64);
          alert("Base64 decoding error. The book file might be corrupted.");
          return null;
        }
      }

      async function decryptFolder(combinedData, password) {
        const iv = combinedData.slice(0, 12);
        const encryptedData = combinedData.slice(12);

        const key = await crypto.subtle.digest(
          "SHA-256",
          new TextEncoder().encode(password)
        );

        const decryptedData = await crypto.subtle.decrypt(
          { name: "AES-GCM", iv },
          await crypto.subtle.importKey(
            "raw",
            key,
            { name: "AES-GCM" },
            false,
            ["decrypt"]
          ),
          encryptedData
        );

        return decryptedData;
      }

      window.onload = loadBook;
    </script>
  </body>
</html>
