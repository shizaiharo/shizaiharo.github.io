<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Enc</title>
  </head>
  <body>
    <h2>Enc</h2>
    <h4>Upload a folder/folders containing the book images</h4>
    <button id="backToIndexButton">Main</button>
    <br />
    <input
      type="file"
      id="bookInput"
      multiple
      webkitdirectory
      style="display: none"
    />
    <button id="uploadBookButton" onclick="uploadBook()" style="display: none">
      Upload Book
    </button>
    <br />
    <input
      type="file"
      id="motherFolderInput"
      multiple
      webkitdirectory
      style="display: none"
    />
    <button
      id="uploadMotherFolderButton"
      onclick="uploadMotherFolder()"
      style="display: none"
    >
      Upload Mother Folder
    </button>
    <p id="status"></p>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>
    <script>
      let token = null;
      const repo = "Amrita"; // Change to your repository name
      const owner = "shizaiharo"; // Change to your GitHub username
      const branch = "main"; // Change to your default branch
      const MAX_ZIP_SIZE = 25 * 1024 * 1024; // After add encryption will near limit 40MiB (40/1.33 = 30)

      const maxWorkers = navigator.hardwareConcurrency || 4; // Fallback to 4 if the property is not supported
      console.log(`Using up to ${maxWorkers} workers.`);

      const workers = [];
      for (let i = 0; i < maxWorkers; i++) {
        const worker = new Worker("worker.js");
        worker.onmessage = async function (e) {
          if (e.data.status === "upload") {
            await uploadToGitHub(
              e.data.folderName,
              e.data.zipIndex,
              e.data.base64CombinedData
            );
          } else if (e.data.status === "complete") {
            document.getElementById(
              "status"
            ).textContent = `Part ${e.data.zipIndex} upload completeâœ…`;
          }
        };
        workers.push(worker);
      }

      let currentWorkerIndex = 0;

      function getNextWorker() {
        const worker = workers[currentWorkerIndex];
        currentWorkerIndex = (currentWorkerIndex + 1) % maxWorkers;
        return worker;
      }

      async function uploadToGitHub(folderName, zipIndex, base64Data) {
        const path = `Books/${folderName}/${folderName}_part${zipIndex}.zip`;
        const url = `https://api.github.com/repos/${owner}/${repo}/contents/${path}`;
        const delay = (ms) => new Promise((res) => setTimeout(res, ms));

        // let sha = null;
        // try {
        //   const response = await fetch(url, {
        //     headers: { Authorization: `Bearer ${token}` },
        //   });
        //   if (response.ok) {
        //     const data = await response.json();
        //     sha = data.sha; // Latest sha required for updates
        //   }
        // } catch (error) {
        //   console.warn("File may not exist yet, proceeding without sha.");
        // }

        // Prepare file data
        const fileData = {
          message: `Upload encrypted folder part ${zipIndex}`,
          content: base64Data, // Base64 encode content
          // sha: sha, // Include sha if updating
          branch: branch,
        };

        let attempts = 0;
        while (true) {
          try {
            const Upload_response = await fetch(url, {
              method: "PUT",
              headers: {
                Authorization: `Bearer ${token}`,
                Accept: "application/vnd.github+json",
                "Content-Type": "application/octet-stream",
              },
              body: JSON.stringify(fileData),
            });

            if (Upload_response.ok) {
              console.log(`Uploaded ${path}`);
              break;
            } else if (Upload_response.status === 422) {
              console.log(`Part ${zipIndex} already exists. Skipping...`);
              break;
            } else {
              const errorData = await Upload_response.json();
              console.error(`Part${zipIndex} upload failed:`, errorData);
              console.log(`Part${zipIndex} retrying upload ${attempts} times`);
              attempts++;
              await delay(1000 * Math.pow(2, attempts)); // Exponential backoff
              // await uploadToGitHub(folderName, zipIndex, base64Data);
            }
          } catch (error) {
            console.error(`Part${zipIndex} Upload error:`, error);
            console.log(`Part${zipIndex} retrying upload ${attempts} times`);
            attempts++;
            await delay(1000 * Math.pow(2, attempts)); // Exponential backoff
            // await uploadToGitHub(folderName, zipIndex, base64Data);
          }
        }
      }

      async function uploadBook() {
        if (!token) {
          alert("Please upload the token file first.");
          return;
        }

        const files = Array.from(document.getElementById("bookInput").files);
        if (files.length === 0) {
          alert("No files selected.");
          return;
        }

        const folderName = files[0].webkitRelativePath.split("/")[0];
        const matchResult = folderName.match(/\[(\d+)\]/);
        if (!matchResult) {
          alert(`Error: No number found in folder name: ${folderName}`);
          return;
        }
        const password = combine("Kyaru", matchResult[1]);

        document.getElementById("status").textContent =
          "Encrypting and uploading...";

        files.sort((a, b) => {
          const numsA = (a.name.match(/\d+/g) || []).map(Number);
          const numsB = (b.name.match(/\d+/g) || []).map(Number);

          for (let i = 0; i < Math.max(numsA.length, numsB.length); i++) {
            if (numsA[i] !== numsB[i]) {
              return (numsA[i] || 0) - (numsB[i] || 0);
            }
          }
          return 0;
        });
        console.log(files);

        // const pendingZip = [];
        // let currentZip = [];
        let currentZipSize = 0;
        let zipIndex = 1;
        let zip = new JSZip();

        for (const file of files) {
          if (file.name === ".DS_Store") {
            continue;
          } else if (file.size > MAX_ZIP_SIZE) {
            const chunkSize = MAX_ZIP_SIZE;
            let start = 0;

            while (start < file.size) {
              const end = Math.min(start + chunkSize, file.size);
              const chunk = file.slice(start, end);

              let zip = new JSZip();
              const chunkName = `${file.name}.part${zipIndex}`;
              zip.file(chunkName, chunk); // Add this chunk as a single file in ZIP

              console.log(`Creating ZIP for chunk: ${chunkName}`);
              document.getElementById(
                "status"
              ).textContent = `Zipping part ${zipIndex}...`;

              const zipBlob = await zip.generateAsync({ type: "blob" });
              const zipArrayBuffer = await zipBlob.arrayBuffer();
              const zipSerialized = Array.from(new Uint8Array(zipArrayBuffer));

              const worker = getNextWorker();
              worker.postMessage({
                action: "ZipEncrypt",
                folderName,
                zip: zipSerialized,
                zipIndex,
                password,
              });
              start = end;
              zipIndex++;
            }
            continue;
          } else {
            if (currentZipSize + file.size > MAX_ZIP_SIZE) {
              const zipBlob = await zip.generateAsync({ type: "blob" });
              const zipArrayBuffer = await zipBlob.arrayBuffer();
              const zipSerialized = Array.from(new Uint8Array(zipArrayBuffer));

              const worker = getNextWorker();
              worker.postMessage({
                action: "ZipEncrypt",
                folderName,
                zip: zipSerialized,
                zipIndex,
                password,
              });
              zip = new JSZip();
              currentZipSize = 0;
              zipIndex++;
            }
            console.log(
              `Adding file to zip: ${file.webkitRelativePath || file.name}`
            );
            zip.file(file.webkitRelativePath || file.name, file);
            currentZipSize += file.size;
          }
        }
        if (currentZipSize > 0) {
          const zipBlob = await zip.generateAsync({ type: "blob" });
          const zipArrayBuffer = await zipBlob.arrayBuffer();
          const zipSerialized = Array.from(new Uint8Array(zipArrayBuffer));

          const worker = getNextWorker();
          worker.postMessage({
            action: "ZipEncrypt",
            folderName,
            zip: zipSerialized,
            zipIndex,
            password,
          });
        }
      }

      // function splitFilesIntoChunks(files, maxSize) {
      //   const pendingZip = [];
      //   let currentZip = [];
      //   let currentSize = 0;

      //     if (file.name === ".DS_Store") return;

      //     if (file.size > maxSize) {
      //       const chunkSize = MAX_ZIP_SIZE;
      //       let partIndex = 1;
      //       let start = 0;

      //       while (start < file.size) {
      //         const end = Math.min(start + chunkSize, file.size);
      //         const chunk = file.slice(start, end);

      //         let zip = new JSZip();
      //         const chunkName = `${file.name}.part${partIndex}`;
      //         zip.file(chunkName, chunk); // Add this chunk as a single file in ZIP

      //         // console.warn(`Split file to part${zipIndex}: ${file.name}`);
      //         // await processZip(zip, password, zipIndex, folderName);
      //         pendingZip.push(zip);
      //         start = end;
      //         partIndex++;
      //       }

      //     }

      //     if (currentSize + file.size > maxSize) {
      //       pendingZip.push(currentZip);
      //       currentZip = [];
      //       currentSize = 0;
      //     }

      //     currentZip.push(file);
      //     // console.log(`Adding file to part${partIndex}: ${file.name}`);
      //     currentSize += file.size;
      //   });

      //   if (currentZip.length > 0) {
      //     pendingZip.push(currentZip);
      //   }

      //   return pendingZip;
      // }

      function getTokenFromUrl() {
        const urlParams = new URLSearchParams(window.location.search);
        token = urlParams.get("token");
        if (token) {
          document.getElementById("bookInput").style.display = "inline";
          document.getElementById("uploadBookButton").style.display = "inline";
          document.getElementById("motherFolderInput").style.display = "inline";
          document.getElementById("uploadMotherFolderButton").style.display =
            "inline";
        } else {
          alert("Please upload the token file first.");
        }
        document.getElementById("backToIndexButton").onclick = function () {
          window.location.href = `index.html${
            token ? `?token=${encodeURIComponent(token)}` : ""
          }`;
        };
      }

      function combine(str1, str2) {
        const combined = [];
        const len1 = str1.length;
        const len2 = str2.length;
        const maxLen = Math.max(len1, len2);

        for (let i = 0; i < maxLen; i++) {
          if (i < len1) {
            combined.push(str1[i]);
          } else {
            combined.push("!");
          }

          if (i < len2) {
            combined.push(str2[i]);
          }
        }

        return combined.join("");
      }

      // Don't change this function because of error "RangeError: too many arguments provided for a function call"
      // function bufferToBase64(buffer) {
      //   return btoa(
      //     new Uint8Array(buffer).reduce(
      //       (data, byte) => data + String.fromCharCode(byte),
      //       ""
      //     )
      //   );
      // }

      // function base64ToArrayBuffer(base64) {
      //   const binaryString = atob(base64);
      //   const bytes = new Uint8Array(binaryString.length);
      //   for (let i = 0; i < binaryString.length; i++) {
      //     bytes[i] = binaryString.charCodeAt(i);
      //   }
      //   return bytes.buffer;
      // }

      // let uploadQueue = [];
      // let isUploading = false;

      // async function encryptFolder(files, password, folderName) {
      //   const chunks = splitFilesIntoChunks(files, MAX_ZIP_SIZE);
      //   chunks.forEach((chunk, index) => {
      //     const worker = getNextWorker();
      //     worker.postMessage({
      //       action: "encryptAndZip",
      //       files: chunk,
      //       password,
      //       folderName,
      //       zipIndex: index + 1,
      //       MAX_ZIP_SIZE,
      //     });
      //   });
      // }

      async function uploadMotherFolder() {
        if (!token) {
          alert("Please upload the token file first.");
          return;
        }

        const files = Array.from(
          document.getElementById("motherFolderInput").files
        );
        if (files.length === 0) {
          alert("No files selected.");
          return;
        }

        const folders = {};
        files.forEach((file) => {
          const folderName = file.webkitRelativePath.split("/")[1];
          if (/\[\d+\]/.test(folderName)) {
            if (!folders[folderName]) {
              folders[folderName] = [];
            }
            folders[folderName].push(file);
          }
        });

        const sortedFolderNames = Object.keys(folders).sort((a, b) => {
          const numA = parseInt(a.match(/\[(\d+)\]/)[1]);
          const numB = parseInt(b.match(/\[(\d+)\]/)[1]);
          return numA - numB;
        });

        for (const folderName of sortedFolderNames) {
          const folderFiles = folders[folderName];
          const matchResult = folderName.match(/\[(\d+)\]/);
          if (!matchResult) {
            alert(`Error: No number found in folder name: ${folderName}`);
            return;
          }
          const numberInBracket = matchResult[1];
          const password = combine("Kyaru", numberInBracket);

          document.getElementById(
            "status"
          ).textContent = `Encrypting and uploading folder: ${folderName}...`;

          await encryptFolder(folderFiles, password, folderName);
        }
      }

      window.onload = getTokenFromUrl;
    </script>
  </body>
</html>
